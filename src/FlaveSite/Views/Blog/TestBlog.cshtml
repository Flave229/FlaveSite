@using Microsoft.AspNetCore.Mvc.Rendering

<div class="header-details" @*style="background-image: url(@Model.ImageUrl)"*@></div>
<div class="header-details-content">
    <div class="row" style="top: 50%">
        <div class="col-md-4"></div>
        <div class="col-md-4 header-profile">
            <span class="header-profile-title"> TestPage </span>  
        </div>
        <div class="col-md-4"></div>
    </div>
</div>
@Html.Partial("Navbar")


<div class="container body-content" style="font-family: Arial">
    <h4>Introduction</h4>
    Where better to start a blog for a website, than digging up some code you wrote over two years ago and ripping it apart! I first started programming using DirectX in 2015, where the majority of this code was written. A warning to the more experienced programmers, the code I am about to reveal is HORRIBLY hacked together and would likely even cause the strong willed to wince. The objective of this exercise is mainly to discover how far I have progressed since first using DirectX 2 years ago, while also giving me a lesson in refactoring evil rookie code. So, let's delve into the abyss!
    <br><br>
    <h4>Problem Identification</h4>
    Immediately, upon loading the application, it was apparent that were was a huge issue with memory being leaked at runtime [Figure 1]. Can’t fault past me for creating a fun project for myself 2 years down the line...
    <br><br>
    <div class="row" style="text-align: center">
        <div class="col-md-1"></div>
        <div class="col-md-10">
            <img src="/images/blog/1-1.png" style="max-width: 100%" />
            <br>
            <p style="color: #888888">Figure 1 - Memory Leaks!</p>
        </div>
        <div class="col-md-1"></div>
    </div>
    <br>
    Not to mention that most of the code for this application seems to be situated within the main "Application" class, consisting of 1530 lines. I can't bear to look at how many layers of nested if statements exist in this frankensteined code. With only a quick glace at the project, it is clear what problems need addressing in this first refactor.
    <br><br>
    <h4>Plugging the Memory Leak</h4>
    After overcoming the guilt and shame of ever having written this code, it was time to work on righting that wrong and removing the offending code from existence. First, we need to locate the source of the memory leak, which can be done by using Visual Studio's built in Performance Profiler.
    <br><br>
    <div class="row" style="text-align: center">
        <div class="col-md-1"></div>
        <div class="col-md-10">
            <img src="/images/blog/1-2.png"  style="max-width: 100%" />
            <br>
            <p style="color: #888888">Figure 2 - Allocations happening in Application::Update over the course of 6 seconds</p>
        </div>
        <div class="col-md-1"></div>
    </div>
    <br>
    So, let's look at what Billboard::Update() is doing:
    <br><br>
    <div class="code-block">
<samp>HRESULT Billboard::Update(float delta, ID3D11Device * pd3dDevice, XMFLOAT3 eyePos)
{
    HRESULT hr;

    // convert data into usable format
    XMFLOAT3 worldPos = XMFLOAT3(GetTransform()->GetWorld()._41, GetTransform()->GetWorld()._42, GetTransform()->GetWorld()._43);

    // Calculate the normal vector which will make the billboard face the camera
    XMFLOAT3 planeNormal; // = worldPos - camEyePos;

    if (_xAxisLock)
        planeNormal.x = 0.0f;
    else
        planeNormal.x = (worldPos.x * 2) - eyePos.x;

    if (_yAxisLock)
        planeNormal.y = 0.0f;
    else
        planeNormal.y = (worldPos.y * 2) - eyePos.y;

    if (_zAxisLock)
        planeNormal.z = 0.0f;
    else
        planeNormal.z = (worldPos.z * 2) - eyePos.z;

    // Translate normal float to vector and normalize
    XMVECTOR vectorNormal = XMLoadFloat3(&planeNormal);
    vectorNormal = XMVector3Normalize(vectorNormal);

    // Translate up float to vector
    XMFLOAT3 floatUp = XMFLOAT3(0.0f, 1.0f, 0.0f);
    XMVECTOR vectorUp = XMLoadFloat3(&floatUp);

    XMVECTOR vectorRight = XMVector3Normalize(XMVector3Cross(vectorNormal, vectorUp));
    vectorRight = vectorRight * (GetAppearance()->GetWidth() / 2);

    floatUp = XMFLOAT3(0.0f, (GetAppearance()->GetHeight() / 2), 0.0f);
    vectorUp = XMLoadFloat3(&floatUp);

    // Build Vertex buffer
    XMFLOAT3 vert[4];
    XMFLOAT3 vertToConvert[4] = { XMFLOAT3(0.0f, 0.0f, 0.0f), XMFLOAT3(0.0f, 0.0f, 0.0f), XMFLOAT3(0.0f, 0.0f, 0.0f), XMFLOAT3(0.0f, 0.0f, 0.0f) };

    XMStoreFloat3(&vertToConvert[0], (-vectorRight));
    XMStoreFloat3(&vertToConvert[1], vectorRight);
    XMStoreFloat3(&vertToConvert[2], (-vectorRight) + vectorUp);
    XMStoreFloat3(&vertToConvert[3], vectorRight + vectorUp);
    
    vert[0] = XMFLOAT3(worldPos.x + vertToConvert[0].x, worldPos.y + vertToConvert[0].y, worldPos.z + vertToConvert[0].z);
    vert[1] = XMFLOAT3(worldPos.x + vertToConvert[1].x, worldPos.y + vertToConvert[1].y, worldPos.z + vertToConvert[1].z);
    vert[2] = XMFLOAT3(worldPos.x + vertToConvert[2].x, worldPos.y + vertToConvert[2].y, worldPos.z + vertToConvert[2].z);
    vert[3] = XMFLOAT3(worldPos.x + vertToConvert[3].x, worldPos.y + vertToConvert[3].y, worldPos.z + vertToConvert[3].z);

    // Pine Tree
    // Create vertex buffer
    SimpleVertex vertices[] =
    {
        { vert[0], vert[0], XMFLOAT2(0.0f, 1.0f) },
        { vert[1], vert[1], XMFLOAT2(1.0f, 1.0f) },
        { vert[2], vert[2], XMFLOAT2(0.0f, 0.0f) },
        { vert[3], vert[3], XMFLOAT2(1.0f, 0.0f) },
    };

    D3D11_BUFFER_DESC bd;
    ZeroMemory(&bd, sizeof(bd));
    bd.Usage = D3D11_USAGE_DEFAULT;
    bd.ByteWidth = sizeof(SimpleVertex) * 4;
    bd.BindFlags = D3D11_BIND_VERTEX_BUFFER;
    bd.CPUAccessFlags = 0;

    D3D11_SUBRESOURCE_DATA InitData;
    ZeroMemory(&InitData, sizeof(InitData));
    InitData.pSysMem = vertices;

    // Update Stride and offset
    GetAppearance()->GetGeometryData()->VBOffset = 0;
    GetAppearance()->GetGeometryData()->VBStride = sizeof(SimpleVertex);

    hr = pd3dDevice->CreateBuffer(&bd, &InitData, &GetAppearance()->GetGeometryData()->VertexBuffer);

    GameObject::Update(delta);

    if (FAILED(hr))
        return hr;
    
    return S_OK;
}</samp>
    </div>
    <br/>
    What a mess. Let's start by moving some of this logic out into different methods so we can understand it better. This will also have the added benefit of narrowing down the exact section of code causing the leak in the performance profiler. We can also pass the eyePos by const reference as we do not change the data and we want to avoid copying data wherever possible. The new code looks something like this:
    <br><br>
    <div class="code-block">
<samp>HRESULT Billboard::Update(const float delta, ID3D11Device* pd3dDevice, const XMFLOAT3& eyePosition)
{
    // Extracting world position from matrix
    const XMFLOAT3 worldPosition = XMFLOAT3(GetTransform()->GetWorld()._41, GetTransform()->GetWorld()._42, GetTransform()->GetWorld()._43);

    const XMVECTOR vectorNormal = CalculateBillboardNormal(worldPosition, eyePosition);

    XMFLOAT3 floatUp = XMFLOAT3(0.0f, 1.0f, 0.0f);
    XMVECTOR vectorUp = XMLoadFloat3(&floatUp);

    XMVECTOR vectorRight = XMVector3Normalize(XMVector3Cross(vectorNormal, vectorUp));
    vectorRight = vectorRight * (GetAppearance()->GetWidth() / 2);

    floatUp = XMFLOAT3(0.0f, GetAppearance()->GetHeight() / 2, 0.0f);
    vectorUp = XMLoadFloat3(&floatUp);

    HRESULT hr = CreateVertexBuffer(pd3dDevice, worldPosition, vectorRight, vectorUp);
    if (FAILED(hr))
        return hr;

    GameObject::Update(delta);
	
    return S_OK;
}</samp>
    </div>
    <br />
    Much better! As expected, this has helped the Memory Profiler narrow down the offending piece of code [Figure 3].
    <br><br>
    <div class="row" style="text-align: center">
        <div class="col-md-1"></div>
        <div class="col-md-10">
            <img src="/images/blog/1-3.png" style="max-width: 100%" />
            <br>
            <p style="color: #888888">Figure 3 - Seperating the code out into methods further reveals the offending code</p>
        </div>
        <div class="col-md-1"></div>
    </div>
    <br>
    Looking at the code that constructs the Vertex Buffer, it is fairly obvious where the leak is occuring. The VertexBuffer we pass into the <code>pd3dDevice->CreateBuffer()</code> asks for a pointer to a pointer of type <code>ID3D11Buffer</code>. This is problematic when we are constantly changing this value each frame, as the previous pointer allocated on the previous frame is never cleared. A naive fix to this would be to clean up the memory at the top of the method:
    <br><br>
    <div class="code-block">
<samp>HRESULT Billboard::CreateVertexBuffer(ID3D11Device* pd3dDevice, const XMFLOAT3& worldPosition, const XMVECTOR& vectorRight, const XMVECTOR& vectorUp)
{
    GetAppearance()->GetGeometryData()->VertexBuffer->Release();
    delete GetAppearance()->GetGeometryData()->VertexBuffer;
    GetAppearance()->GetGeometryData()->VertexBuffer = nullptr;

    ...

    return pd3dDevice->CreateBuffer(&bd, &InitData, &GetAppearance()->GetGeometryData()->VertexBuffer);
}</samp>
    </div>
</div>

@Html.Partial("MainFooter")